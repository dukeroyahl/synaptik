name: Release & Deployment

on:
  push:
    tags:
      - '*'
  delete:
    # Trigger when tags are deleted
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to build (e.g., 1.2.3)'
        required: true
        type: string
      create_release:
        description: 'Create GitHub release'
        required: false
        default: true
        type: boolean

concurrency:
  group: release-${{ github.event.ref || github.ref || github.event.inputs.version }}
  cancel-in-progress: false

permissions:
  contents: write
  packages: write
  actions: read
  id-token: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  GRADLE_OPTS: '-Dorg.gradle.daemon=false -Dorg.gradle.parallel=true -Dorg.gradle.caching=true'

jobs:
  # ============================================================================
  # TAG VALIDATION & RELEASE CREATION
  # ============================================================================
  
  validate-tag:
    runs-on: ubuntu-latest
    if: github.event_name != 'delete'
    outputs:
      is_semver: ${{ steps.check.outputs.is_semver }}
      version: ${{ steps.check.outputs.version }}
      should_create_release: ${{ steps.check.outputs.should_create_release }}
      tag_name: ${{ steps.check.outputs.tag_name }}
    steps:
      - name: Check if tag/version is semantic version
        id: check
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TAG_NAME="v${{ github.event.inputs.version }}"
            VERSION="${{ github.event.inputs.version }}"
            SHOULD_CREATE="${{ github.event.inputs.create_release }}"
          else
            TAG_NAME="${{ github.ref_name }}"
            VERSION=${TAG_NAME#v}  # Remove 'v' prefix if present
            SHOULD_CREATE="true"
          fi
          
          echo "Checking tag: $TAG_NAME (version: $VERSION)"
          
          # Always set tag_name and version outputs
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          
          # Check if it matches semantic versioning pattern
          if [[ $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "✅ Tag $TAG_NAME matches semantic versioning"
            echo "is_semver=true" >> $GITHUB_OUTPUT
            echo "should_create_release=$SHOULD_CREATE" >> $GITHUB_OUTPUT
          else
            echo "ℹ️ Tag $TAG_NAME does not match semantic versioning (x.y.z) - ignoring"
            echo "is_semver=false" >> $GITHUB_OUTPUT
            echo "should_create_release=false" >> $GITHUB_OUTPUT
          fi

  generate-release-notes:
    needs: validate-tag
    runs-on: ubuntu-latest
    if: needs.validate-tag.outputs.should_create_release == 'true'
    outputs:
      release_notes: ${{ steps.notes.outputs.release_notes }}
      previous_tag: ${{ steps.previous.outputs.previous_tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get previous release tag
        id: previous
        run: |
          # Get all tags sorted by version
          PREVIOUS_TAG=$(git tag -l --sort=-version:refname | grep -E '^v?[0-9]+\.[0-9]+\.[0-9]+$' | sed -n '2p')
          if [ -z "$PREVIOUS_TAG" ]; then
            # If no previous tag, use first commit
            PREVIOUS_TAG=$(git rev-list --max-parents=0 HEAD)
            echo "No previous semantic version tag found, using first commit"
          fi
          echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT
          echo "Previous tag/commit: $PREVIOUS_TAG"

      - name: Generate release notes
        id: notes
        run: |
          CURRENT_TAG="${{ needs.validate-tag.outputs.tag_name }}"
          PREVIOUS_TAG="${{ steps.previous.outputs.previous_tag }}"
          VERSION="${{ needs.validate-tag.outputs.version }}"
          
          echo "Generating release notes from $PREVIOUS_TAG to $CURRENT_TAG"
          
          # Get commit messages and categorize them
          COMMITS=$(git log --pretty=format:"%s" $PREVIOUS_TAG..$CURRENT_TAG 2>/dev/null || echo "Initial release")
          
          # Categorize commits
          FEATURES=""
          FIXES=""
          IMPROVEMENTS=""
          OTHER=""
          
          if [ "$COMMITS" != "Initial release" ]; then
            while IFS= read -r commit; do
              if [[ $commit =~ ^feat.*|^add.*|^implement.* ]]; then
                FEATURES="$FEATURES- $commit"$'\n'
              elif [[ $commit =~ ^fix.*|^resolve.*|^correct.* ]]; then
                FIXES="$FIXES- $commit"$'\n'
              elif [[ $commit =~ ^improve.*|^enhance.*|^update.*|^refactor.*|^optimize.* ]]; then
                IMPROVEMENTS="$IMPROVEMENTS- $commit"$'\n'
              else
                OTHER="$OTHER- $commit"$'\n'
              fi
            done <<< "$COMMITS"
          fi
          
          # Create release notes with improved structure
          cat > release_notes.md << EOF
          ## ✨ What's New
          
          EOF
          
          # Add categorized changes
          if [ -n "$FEATURES" ]; then
            cat >> release_notes.md << EOF
          ### 🎯 **New Features**
          $FEATURES
          EOF
          fi
          
          if [ -n "$FIXES" ]; then
            cat >> release_notes.md << EOF
          ### 🐛 **Bug Fixes**
          $FIXES
          EOF
          fi
          
          if [ -n "$IMPROVEMENTS" ]; then
            cat >> release_notes.md << EOF
          ### 🏗️ **Improvements**
          $IMPROVEMENTS
          EOF
          fi
          
          if [ -n "$OTHER" ] && [ "$COMMITS" != "Initial release" ]; then
            cat >> release_notes.md << EOF
          ### 📝 **Other Changes**
          $OTHER
          EOF
          fi
          
          if [ "$COMMITS" = "Initial release" ]; then
            cat >> release_notes.md << EOF
          ### 🎉 **Initial Release**
          - Welcome to Synaptik - your streamlined task management system!
          
          EOF
          fi
          
          # Add installation options with improved formatting
          cat >> release_notes.md << 'RELEASE_NOTES_END'
          ---
          
          ## 📦 Installation Options
          
          *Choose the installation method that works best for you:*
          
          ### 🚀 **Option 1: Quick Install** *(Recommended for most users)*
          
          **Perfect for:** First-time users who want to get started immediately
          
          ```bash
          curl -sSL https://raw.githubusercontent.com/dukeroyahl/synaptik/main/install.sh | bash
          ```
          
          **What you get:**
          - ✅ Full Synaptik application running on `http://localhost:4000`
          - ✅ REST API available on `http://localhost:8060` 
          - ✅ Docker containers managed automatically
          - ✅ Persistent data storage
          
          **Time to setup:** ~2 minutes
          
          ---
          
          ### 🤖 **Option 2: Claude Desktop Integration**
          
          **Perfect for:** Users who want AI-powered task management
          
          **Step 1:** Install Synaptik (use Quick Install above)
          
          **Step 2:** Get the MCP server
          ```bash
          # Download native binary for this release (v$VERSION)
          curl -sSL https://github.com/dukeroyahl/synaptik/releases/download/v$VERSION/synaptik-mcp-darwin-arm64 -o synaptik-mcp
          chmod +x synaptik-mcp
          
          # OR download latest stable
          curl -sSL https://github.com/dukeroyahl/synaptik/releases/latest/download/synaptik-mcp-darwin-arm64 -o synaptik-mcp
          chmod +x synaptik-mcp
          
          # OR build from source
          cd mcp && ./gradlew quarkusBuild
          ```
          
          **Step 3:** Configure Claude Desktop
          Add to your Claude config file (`~/Library/Application Support/Claude/claude_desktop_config.json`):
          
          ```json
          {
            "mcpServers": {
              "synaptik": {
                "command": "/path/to/synaptik-mcp"
              }
            }
          }
          ```
          
          **Step 4:** Restart Claude Desktop
          
          **What you can do:**
          - *"Show me my active tasks"*
          - *"Create a task to review the quarterly report"*  
          - *"Mark the database backup task as complete"*
          
          ---
          
          ### 🐳 **Option 3: Docker Images**
          
          **Perfect for:** Developers and advanced users who need customization
          
          ```bash
          # This Release (v$VERSION)
          docker pull ghcr.io/dukeroyahl/synaptik/frontend:$VERSION
          docker pull ghcr.io/dukeroyahl/synaptik/backend:$VERSION
          
          # Or latest stable
          docker pull ghcr.io/dukeroyahl/synaptik/frontend:latest
          docker pull ghcr.io/dukeroyahl/synaptik/backend:latest
          ```
          
          **Use case:** Custom deployments, development environments, CI/CD pipelines
          
          ---
          
          ### ⚡ **Option 4: Native Binaries**
          
          **Perfect for:** Performance-focused users and system integrators
          
          **Available Platforms:**
          - 🍎 **macOS Apple Silicon** *(Primary platform - fully tested)*
          - 🐧 **Linux x86_64** 
          
          **Downloads for v$VERSION:**
          - [synaptik-mcp-darwin-arm64](https://github.com/dukeroyahl/synaptik/releases/download/v$VERSION/synaptik-mcp-darwin-arm64)
          - [synaptik-mcp-linux-amd64](https://github.com/dukeroyahl/synaptik/releases/download/v$VERSION/synaptik-mcp-linux-amd64)
          
          **Or get latest stable:**
          - [synaptik-mcp-darwin-arm64](https://github.com/dukeroyahl/synaptik/releases/latest/download/synaptik-mcp-darwin-arm64)
          - [synaptik-mcp-linux-amd64](https://github.com/dukeroyahl/synaptik/releases/latest/download/synaptik-mcp-linux-amd64)
          
          **Benefits:** Faster startup, lower memory usage, no Java runtime required
          
          ---
          
          ## 📚 **Resources**
          
          - 📖 [Full Documentation](https://github.com/dukeroyahl/synaptik/wiki)
          - 🤝 [Contributing Guide](https://github.com/dukeroyahl/synaptik/blob/main/CONTRIBUTING.md)
          - 🐛 [Report Issues](https://github.com/dukeroyahl/synaptik/issues)
          - 📦 [Docker Hub](https://hub.docker.com/r/roudranil/synaptik)
          
          ---
          
          **Full Changelog**: https://github.com/dukeroyahl/synaptik/compare/$PREVIOUS_TAG...$CURRENT_TAG
          RELEASE_NOTES_END
          
          # Substitute the version variable
          sed -i "s/\$VERSION/$VERSION/g" release_notes.md
          
          # Output the release notes (escape for GitHub Actions)
          {
            echo 'release_notes<<EOF'
            cat release_notes.md
            echo EOF
          } >> $GITHUB_OUTPUT

  create-release:
    needs: [validate-tag, generate-release-notes]
    runs-on: ubuntu-latest
    if: needs.validate-tag.outputs.should_create_release == 'true'
    outputs:
      release_id: ${{ steps.create.outputs.release_id }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Create GitHub Release
        id: create
        run: |
          TAG_NAME="${{ needs.validate-tag.outputs.tag_name }}"
          VERSION="${{ needs.validate-tag.outputs.version }}"
          
          echo "🔍 Creating release for tag: $TAG_NAME (version: $VERSION)"
          
          # Check if release already exists and delete it
          if gh api repos/dukeroyahl/synaptik/releases/tags/$TAG_NAME 2>/dev/null; then
            echo "⚠️ Release for $TAG_NAME already exists, deleting it first..."
            EXISTING_RELEASE_ID=$(gh api repos/dukeroyahl/synaptik/releases/tags/$TAG_NAME --jq '.id')
            gh api repos/dukeroyahl/synaptik/releases/$EXISTING_RELEASE_ID --method DELETE
            echo "✅ Deleted existing release"
          fi
          
          # Create the release notes in a temporary file to avoid command line length issues
          cat > /tmp/release_notes.md << 'TEMP_EOF'
          ${{ needs.generate-release-notes.outputs.release_notes }}
          TEMP_EOF
          
          echo "📝 Release notes preview (first 500 chars):"
          head -c 500 /tmp/release_notes.md
          echo ""
          echo "..."
          
          # Create the release using file input for body
          RELEASE_RESPONSE=$(gh api repos/dukeroyahl/synaptik/releases \
            --method POST \
            --field tag_name="$TAG_NAME" \
            --field target_commitish="main" \
            --field name="v$VERSION" \
            --field body=@/tmp/release_notes.md \
            --field draft=false \
            --field prerelease=false)
          
          RELEASE_ID=$(echo "$RELEASE_RESPONSE" | jq -r '.id')
          echo "release_id=$RELEASE_ID" >> $GITHUB_OUTPUT
          echo "✅ Created release v$VERSION with ID: $RELEASE_ID"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ============================================================================
  # BUILD & DEPLOYMENT
  # ============================================================================

  build-docker-images:
    needs: [validate-tag, create-release]
    runs-on: ubuntu-latest
    if: needs.validate-tag.outputs.should_create_release == 'true'
    strategy:
      matrix:
        component: [frontend, backend]
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ matrix.component }}
          tags: |
            type=semver,pattern={{version}},value=v${{ needs.validate-tag.outputs.version }}
            type=raw,value=latest

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./docker/Dockerfile.${{ matrix.component }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

  build-native-binaries:
    needs: [validate-tag, create-release]
    runs-on: ${{ matrix.runner }}
    if: needs.validate-tag.outputs.should_create_release == 'true'
    strategy:
      matrix:
        include:
          - platform: linux-amd64
            runner: ubuntu-latest
            use-native: false
            builder-image: quay.io/quarkus/ubi-quarkus-mandrel-builder-image:23.1.8.0-Final-java21-amd64
          - platform: darwin-arm64
            runner: macos-14
            use-native: true
            builder-image: ""
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker (Linux only)
        if: matrix.use-native == false
        uses: docker/setup-buildx-action@v3

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4
        with:
          cache-read-only: false
          cache-cleanup: on-success

      - name: Install GraalVM (macOS only)
        if: matrix.use-native == true
        uses: graalvm/setup-graalvm@v1
        with:
          java-version: '21'
          distribution: 'graalvm'
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Build MCP native binary
        run: |
          cd mcp
          
          if [ "${{ matrix.use-native }}" = "true" ]; then
            # macOS: Use native GraalVM installation
            ./gradlew build -Dquarkus.native.enabled=true -Dquarkus.native.container-build=false -x test
          else
            # Linux: Use containerized Mandrel builder
            ./gradlew build -Dquarkus.native.enabled=true -Dquarkus.native.container-build=true -Dquarkus.native.builder-image=${{ matrix.builder-image }} -x test
          fi

      - name: Prepare binary for release
        run: |
          cd mcp/build
          
          # Find the generated native binary
          BINARY_NAME=$(find . -name "*-runner" -type f | head -n 1)
          if [ -z "$BINARY_NAME" ]; then
            echo "❌ No native binary found!"
            find . -type f -name "*" | head -20
            exit 1
          fi
          
          # Rename to standard format
          mv "$BINARY_NAME" "synaptik-mcp-${{ matrix.platform }}"
          chmod +x "synaptik-mcp-${{ matrix.platform }}"
          
          # Verify binary
          file "synaptik-mcp-${{ matrix.platform }}"
          ls -la "synaptik-mcp-${{ matrix.platform }}"

      - name: Upload binary to release
        run: |
          TAG_NAME="${{ needs.validate-tag.outputs.tag_name }}"
          BINARY_PATH="mcp/build/synaptik-mcp-${{ matrix.platform }}"
          
          echo "📦 Uploading ${{ matrix.platform }} binary to release $TAG_NAME"
          
          # Upload to release (with --clobber to replace if exists)
          gh release upload "$TAG_NAME" "$BINARY_PATH" --clobber --repo dukeroyahl/synaptik
          
          echo "✅ Successfully uploaded synaptik-mcp-${{ matrix.platform }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  update-package-metadata:
    needs: [validate-tag, build-docker-images]
    runs-on: ubuntu-latest
    if: needs.validate-tag.outputs.should_create_release == 'true'
    steps:
      - name: Update package descriptions
        run: |
          echo "📦 Updating Docker package metadata..."
          
          # Frontend package description
          gh api --method PATCH /orgs/dukeroyahl/packages/container/synaptik%2Ffrontend \
            --field description="🧠 Synaptik Frontend - Smart task management companion with React 18 + TypeScript. Works with Claude Desktop via MCP for AI-powered productivity insights." || true
          
          # Backend package description  
          gh api --method PATCH /orgs/dukeroyahl/packages/container/synaptik%2Fbackend \
            --field description="🧠 Synaptik Backend - Java 21 + Quarkus reactive API server with MongoDB. Provides TaskWarrior-compatible task management and MCP integration for AI assistants." || true
          
          echo "✅ Package metadata updated"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ============================================================================
  # TAG DELETION CLEANUP
  # ============================================================================
  
  cleanup-deleted-tag:
    runs-on: ubuntu-latest
    if: github.event_name == 'delete' && github.event.ref_type == 'tag'
    steps:
      - name: Check if deleted tag was semantic version
        id: check
        run: |
          DELETED_TAG="${{ github.event.ref }}"
          VERSION=${DELETED_TAG#v}  # Remove 'v' prefix if present
          
          echo "Deleted tag: $DELETED_TAG (version: $VERSION)"
          
          # Check if it matches semantic versioning pattern
          if [[ $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "✅ Deleted tag $DELETED_TAG was a semantic version"
            echo "should_cleanup=true" >> $GITHUB_OUTPUT
            echo "tag_name=$DELETED_TAG" >> $GITHUB_OUTPUT
          else
            echo "ℹ️ Deleted tag $DELETED_TAG was not a semantic version - ignoring"
            echo "should_cleanup=false" >> $GITHUB_OUTPUT
          fi

      - name: Delete corresponding release (with retry logic)
        if: steps.check.outputs.should_cleanup == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          DELETED_TAG="${{ steps.check.outputs.tag_name }}"
          
          echo "🔍 Looking for release with tag: $DELETED_TAG"
          echo "Event: ${{ github.event_name }}, Ref: ${{ github.event.ref }}, Ref Type: ${{ github.event.ref_type }}"
          
          # Wait a moment to avoid race conditions with concurrent workflows
          sleep 5
          
          # Check if release exists with retry logic
          for attempt in 1 2 3; do
            echo "Attempt $attempt: Checking for release..."
            
            RELEASE_INFO=$(gh api repos/dukeroyahl/synaptik/releases/tags/$DELETED_TAG 2>/dev/null || echo "null")
            
            if [ "$RELEASE_INFO" = "null" ]; then
              echo "ℹ️ No release found for tag $DELETED_TAG (attempt $attempt)"
              if [ $attempt -eq 3 ]; then
                echo "✅ No release to clean up - this is normal for tag recreation"
                exit 0
              fi
              sleep 3
              continue
            fi
            
            # Release exists, try to delete it
            echo "🗑️ Found release for $DELETED_TAG, attempting to delete..."
            
            if gh api -X DELETE repos/dukeroyahl/synaptik/releases/$(echo "$RELEASE_INFO" | jq -r '.id') 2>/dev/null; then
              echo "✅ Successfully deleted release for tag $DELETED_TAG"
              echo "⚠️ Docker images may still exist - consider manual cleanup if needed"
              exit 0
            else
              echo "⚠️ Failed to delete release (attempt $attempt) - might be in use by concurrent workflow"
              if [ $attempt -eq 3 ]; then
                echo "ℹ️ Could not delete release after 3 attempts - this is acceptable for tag recreation scenarios"
                exit 0
              fi
              sleep 5
            fi
          done